.版本 2

.程序集 注册表操作Ex, , 公开, 注册表操作,包括注册表的读,写.支持64位
.程序集变量 IsWow64, 逻辑型, , , 判断是否为64位系统,如果是则进行64位的读写操作
.程序集变量 m_Error, 整数型
.程序集变量 m_键句柄, 整数型, , , 记录句柄,在类销毁时释放
.程序集变量 m_是否已打开, 逻辑型
.程序集变量 m_当前键目录, 整数型
.程序集变量 m_当前键, 文本型

.子程序 _初始化
    m_当前键 ＝ “”
    IsWow64Process (-1, IsWow64)

.子程序 _销毁
    关闭键Ex ()

.子程序 方法_置为64位Ex_作废
    m_当前键 ＝ “”
    IsWow64 ＝ 真

.子程序 方法_置为32位Ex_作废
    m_当前键 ＝ “”
    IsWow64 ＝ 假

.子程序 关闭键Ex, 整数型, 公开, 关闭一个已经打开的键句柄,关闭之后需要重新调用打开键Ex才能进行其他操作,如果已经关闭则返回-1
    .如果真 (m_是否已打开)
        m_Error ＝ RegCloseKey (m_键句柄)
        m_是否已打开 ＝ 假
        m_当前键 ＝ “”
        m_当前键目录 ＝ -1
        返回 (m_Error)
    .如果真结束
    返回 (-1)

.子程序 打开键Ex, 整数型, 公开, 如果键不存在,则失败.成功键的句柄,失败返回-1,通过取最后错误查看错误码;注意,使用该命令时,如果键已打开,则自动关闭键后在执行本操作
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 变量_F4CC0125, 整数型
    .局部变量 变量_F5CC0125, 整数型
    .局部变量 变量_F6CC0125, 文本型

    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名 且 m_是否已打开)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    .如果 (IsWow64)
        变量_F4CC0125 ＝ #KEY_WOW64_64KEY
    .否则
        变量_F4CC0125 ＝ #KEY_WOW64_32KEY
    .如果结束
    变量_F4CC0125 ＝ 位或 (变量_F4CC0125, #KEY_ALL_ACCESS)
    
    
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (变量_F4CC0125, 变量_F5CC0125)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (变量_F5CC0125, 全路径注册项名, 0, 变量_F4CC0125, m_键句柄)
            RegCloseKey (变量_F5CC0125)
        .如果真结束
        
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 变量_F4CC0125, 变量_F5CC0125)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegOpenKeyExA (变量_F5CC0125, 全路径注册项名, 0, 变量_F4CC0125, m_键句柄)
            RegCloseKey (变量_F5CC0125)
        .如果真结束
        
        
    .默认
        m_Error ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 变量_F4CC0125, m_键句柄)
    .判断结束
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        返回 (m_键句柄)
    .如果真结束
    返回 (-1)
    

.子程序 创建并打开键Ex, 整数型, 公开, 如果键不存在,则创建一个键之后打开,如果键存在则直接打开;返回键的句柄,失败返回-1,通过取最后错误查看错误码;
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 变量_F9CC0125, 整数型
    .局部变量 变量_FACC0125, 整数型

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    .如果真 (m_当前键目录 ＝ 键根目录 且 m_当前键 ＝ 全路径注册项名)
        返回 (m_键句柄)
    .如果真结束
    
    关闭键Ex ()
    变量_F9CC0125 ＝ #KEY_ALL_ACCESS
    .如果 (IsWow64)
        变量_F9CC0125 ＝ 位或 (变量_F9CC0125, #KEY_WOW64_64KEY)
    .否则
        变量_F9CC0125 ＝ 位或 (变量_F9CC0125, #KEY_WOW64_32KEY)
    .如果结束
    
    
    .判断开始 (键根目录 ＝ #HKEY_CURRENT_USER)
        m_Error ＝ RegOpenCurrentUser (变量_F9CC0125, 变量_FACC0125)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (变量_FACC0125, 全路径注册项名, 0, 0, 1, 变量_F9CC0125, #REG_OPTION_NON_VOLATILE, m_键句柄, 0)
            RegCloseKey (变量_FACC0125)
        .如果真结束
        
    .判断 (键根目录 ＝ #HKEY_CURRENT_CONFIG)
        m_Error ＝ RegOpenKeyExA (#HKEY_LOCAL_MACHINE, “SYSTEM\CurrentControlSet\Hardware Profiles\Current”, 0, 变量_F9CC0125, 变量_FACC0125)
        
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            m_Error ＝ RegCreateKeyExA (变量_FACC0125, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 变量_F9CC0125, 0, m_键句柄, 0)
            RegCloseKey (变量_FACC0125)
        .如果真结束
        
    .默认
        
        m_Error ＝ RegCreateKeyExA (键根目录, 全路径注册项名, 0, 0, #REG_OPTION_NON_VOLATILE, 变量_F9CC0125, 0, m_键句柄, 0)
    .判断结束
    
    
    .如果真 (m_Error ＝ #ERROR_SUCCESS)
        m_是否已打开 ＝ 真
        m_当前键目录 ＝ 键根目录
        m_当前键 ＝ 全路径注册项名
        
        返回 (m_键句柄)
    .如果真结束
    
    返回 (-1)

.子程序 枚举子项Ex, 整数型, 公开, 枚举指定项名称下的子项(成功返回子项目数,失败返回-1);
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 子项, 文本型, 参考 可空 数组, 获取的子项数组
    .局部变量 变量_FECC0125, 整数型
    .局部变量 变量_FFCC0125, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    清除数组 (子项)
    
    变量_FFCC0125 ＝ 取空白文本 (256)
    m_Error ＝ RegEnumKeyA (m_键句柄, 变量_FECC0125, 变量_FFCC0125, 256)
    .如果真 (m_Error ≠ 0 且 m_Error ≠ #ERROR_NO_MORE_ITEMS)
        返回 (m_Error)
    .如果真结束
    
    .判断循环首 (m_Error ＝ 0)
        加入成员 (子项, 变量_FFCC0125)
        变量_FECC0125 ＝ 变量_FECC0125 ＋ 1
        m_Error ＝ RegEnumKeyA (m_键句柄, 变量_FECC0125, 变量_FFCC0125, 256)
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (子项))

.子程序 方法_取最后错误代码Ex, 整数型, 公开, 取出这个值后,可以根据GetlastError获取错误信息
    返回 (m_Error)

.子程序 枚举键信息Ex, 整数型, 公开, 枚举指定项名称下的键信息(成功返回键名数,失败返回-1),需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 注册表键信息, 注册表_键, 参考 数组, 作为返回值返回
    .局部变量 变量_03CD0125, 整数型
    .局部变量 变量_04CD0125, 整数型
    .局部变量 变量_06CD0125, 注册表_键

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        m_键句柄 ＝ 打开键Ex (键根目录, 全路径注册项名)
        .如果真 (m_键句柄 ＝ -1)
            返回 (m_Error)
        .如果真结束
        清除数组 (注册表键信息)
    .如果真结束
    变量_06CD0125.键名称 ＝ 取空白文本 (256)
    .判断循环首 (m_键句柄 ≠ 0)
        RegEnumValueA (m_键句柄, 变量_03CD0125, 变量_06CD0125.键名称, 256, 0, 变量_06CD0125.类型, 变量_06CD0125.键值, 变量_04CD0125)
        变量_06CD0125.键值 ＝ 取空白字节集 (变量_04CD0125)
        m_Error ＝ RegEnumValueA (m_键句柄, 变量_03CD0125, 变量_06CD0125.键名称, 256, 0, 变量_06CD0125.类型, 变量_06CD0125.键值, 变量_04CD0125)
        .如果 (m_Error ＝ 0)
            加入成员 (注册表键信息, 变量_06CD0125)
        .否则
            跳出循环 ()
        .如果结束
        变量_03CD0125 ＝ 变量_03CD0125 ＋ 1
    .判断循环尾 ()
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        m_Error ＝ 0
    .如果真结束
    返回 (取数组成员数 (注册表键信息))

.子程序 键是否存在Ex, 逻辑型, 公开, 判断键是否存在,亦可可以直接使用"打开键Ex"进行判断
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 变量_09CD0125, 整数型
    .局部变量 变量_0ACD0125, 整数型
    .局部变量 变量_0BCD0125, 整数型

    变量_09CD0125 ＝ #KEY_READ
    .如果 (IsWow64)
        变量_09CD0125 ＝ 位或 (变量_09CD0125, #KEY_WOW64_64KEY)
    .否则
        变量_09CD0125 ＝ 位或 (变量_09CD0125, #KEY_WOW64_32KEY)
    .如果结束
    
    
    
    变量_0BCD0125 ＝ RegOpenKeyExA (键根目录, 全路径注册项名, 0, 变量_09CD0125, 变量_0ACD0125)
    RegCloseKey (变量_0ACD0125)
    
    .如果真 (变量_0BCD0125 ＝ #ERROR_SUCCESS)
        返回 (真)
    .如果真结束
    返回 (假)
    

.子程序 读取键值Ex, 整数型, 公开, 成功返回0,失败返回错误码.需要先调用打开键Ex或打开键Ex2
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 项目信息_out, 注册表_键, 参考, 用于返回的
    .局部变量 变量_B5DB0225, 整数型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    项目信息_out.键名称 ＝ 全路径注册项名
    m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, { }, 变量_B5DB0225)
    .如果真 (m_Error ＝ #ERROR_MORE_DATA)
        项目信息_out.键值 ＝ 取空白字节集 (变量_B5DB0225)
        m_Error ＝ RegQueryValueExA (m_键句柄, 键名称, 0, 项目信息_out.类型, 项目信息_out.键值, 变量_B5DB0225)
        .如果真 (m_Error ＝ #ERROR_SUCCESS)
            项目信息_out.键值 ＝ 取字节集左边 (项目信息_out.键值, 取字节集长度 (项目信息_out.键值) － 1)
        .如果真结束
        
    .如果真结束
    返回 (m_Error)

.子程序 写入键值Ex_文本, 整数型, 公开, 成功返回0,失败返回错误码；注意，该函数只能写入文本型的值
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 字节集, , 使用 到字节集()
    .参数 写入类型, 整数型, , 只适用于：REG_SZ;REG_EXPAND_SZ;REG_MULTI_SZ;#REG_BINARY
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 变量_16CD0125, 整数型
    .局部变量 变量_120F0325, 整数型

    .如果真 (写入类型 ≠ #REG_SZ 且 写入类型 ≠ #REG_EXPAND_SZ 且 写入类型 ≠ #REG_MULTI_SZ 且 写入类型 ≠ #REG_BINARY)
        输出调试文本 (“写入的类型不正确，如果需要写入数值型，请调用【写入键值Ex_数值】”)
        返回 (-1)
    .如果真结束
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            变量_16CD0125 ＝ 创建并打开键Ex (键根目录, 全路径注册项名)
        .默认
            变量_16CD0125 ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (变量_16CD0125 ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    变量_120F0325 ＝ 取字节集长度 (欲写入值)
    欲写入值 ＝ 欲写入值 ＋ { 0 }
    m_Error ＝ RegSetValueExA (m_键句柄, 键名称, 0, 写入类型, 欲写入值, 变量_120F0325)
    返回 (m_Error)

.子程序 写入键值Ex_数值, 整数型, 公开
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 欲写入值, 长整数型, , 注意。理论上：DWORD最大值为：4294967295  QWORD最大值为：18446744073709551615，但是QWORD最大值超过了整数型的最大长度，请谨慎使用
    .参数 写入类型, 整数型, , 只适用于：#REG_DWORD;#REG_DWORD_BIG_ENDIAN;
    .参数 是否自动创建, 逻辑型, 可空, 如果不存在的话，是否创建该键
    .局部变量 变量_30E10125, 整数型
    .局部变量 变量_6DE10125, 字节集
    .局部变量 变量_72E10125, 整数型

    .如果真 (写入类型 ≠ #REG_DWORD 且 写入类型 ≠ #REG_DWORD_BIG_ENDIAN 且 写入类型 ≠ #REG_QWORD)
        输出调试文本 (“写入的类型不正确，如果需要写入文本值，请调用【写入键值Ex_文本】”)
        返回 (-1)
    .如果真结束
    
    .如果真 (是否自动创建)
        m_当前键 ＝ “1”
    .如果真结束
    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .判断开始 (是否自动创建)
            变量_30E10125 ＝ 创建并打开键Ex (键根目录, 全路径注册项名)
        .默认
            变量_30E10125 ＝ 打开键Ex (键根目录, 全路径注册项名)
        .判断结束
        
        .如果真 (变量_30E10125 ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    变量_6DE10125 ＝ 到字节集 (欲写入值)
    变量_72E10125 ＝ 4
    .如果真 (写入类型 ＝ #REG_QWORD)
        补充字节集长度 (变量_6DE10125, 8)
        变量_72E10125 ＝ 8
    .如果真结束
    
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, 写入类型, 变量_6DE10125, 变量_72E10125)
    返回 (m_Error)

.子程序 写QWORD_64值, 逻辑型, 公开, 写入64位长整数值,成功返回真,失败返回假.源码由@pp25729391提供。
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名称, 文本型, , 键的名称
    .参数 值_十六进制文本, 文本型
    .局部变量 变量_87E10125, 字节集
    .局部变量 变量_8BE10125, 整数型

    .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
        创建并打开键Ex (键根目录, 全路径注册项名)
    .如果真结束
    .变量循环首 (取文本长度 (值_十六进制文本), 1, -2, 变量_8BE10125)
        .如果真 (变量_8BE10125 ≠ 1)
            变量_87E10125 ＝ 变量_87E10125 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, 变量_8BE10125 － 1, 2))), 1)
        .如果真结束
        .如果真 (变量_8BE10125 ＝ 1)
            变量_87E10125 ＝ 变量_87E10125 ＋ 取字节集左边 (到字节集 (进制_十六到十 (取文本中间 (值_十六进制文本, 变量_8BE10125, 1))), 1)
        .如果真结束
        
    .变量循环尾 ()
    补充字节集长度 (变量_87E10125, 8)
    m_Error ＝ RegSetValueExA_数值 (m_键句柄, 键名称, 0, #REG_QWORD, 变量_87E10125, 8)
    返回 (m_Error ＝ 0)

.子程序 补充字节集长度
    .参数 变量_69E10125, 字节集
    .参数 变量_6AE10125, 整数型
    .局部变量 变量_6BE10125, 整数型
    .局部变量 变量_6CE10125, 整数型

    .如果真 (变量_6AE10125 ＞ 取字节集长度 (变量_69E10125))
        变量_6BE10125 ＝ 变量_6AE10125 － 取字节集长度 (变量_69E10125)
        .计次循环首 (变量_6BE10125, 变量_6CE10125)
            变量_69E10125 ＝ 变量_69E10125 ＋ { 0 }
        .计次循环尾 ()
    .如果真结束
    返回 ()

.子程序 删除键值Ex, 整数型, 公开, 删除一个键值.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .参数 键名, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (m_Error)
        .如果真结束
        
    .如果真结束
    
    m_Error ＝ DLL_RegDeleteValueA (m_键句柄, 键名)
    返回 (m_Error)

.子程序 删除注册表项, 整数型, 公开, 删除整个项,项下面所有的键值将会被自动删除.
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 变量_1CCD0125, 整数型
    .局部变量 变量_1DCD0125, 文本型

    变量_1CCD0125 ＝ 倒找文本 (全路径注册项名, “\”, , 假)
    变量_1DCD0125 ＝ 取文本左边 (全路径注册项名, 变量_1CCD0125 － 1)
    .如果真 (打开键Ex (键根目录, 变量_1DCD0125) ＝ -1)
        返回 (m_Error)
    .如果真结束
    
    变量_1DCD0125 ＝ 取文本右边 (全路径注册项名, 取文本长度 (全路径注册项名) － 变量_1CCD0125)
    m_Error ＝ RegDeleteKeyA (m_键句柄, 变量_1DCD0125)
    返回 (m_Error)
    

.子程序 格式化键值类型, 文本型, 公开, 说明键值
    .参数 键值, 整数型, , REG_*

    .如果真 (键值 ＞ 11 或 键值 ≤ 0)
        返回 (“键值非法”)
    .如果真结束
    返回 (多项选择 (键值, “REG_SZ”, “REG_EXPAND_SZ”, “REG_BINARY”, “REG_DWORD”, “REG_DWORD_BIG_ENDIAN”, “REG_LINK”, “REG_MULTI_SZ”, “REG_RESOURCE_LIST”, “NULL”, “NULL”, “REG_QWORD”))
    

.子程序 是否有子项Ex, 整数型, 公开, -1=失败 0=无 1=有
    .参数 键根目录, 整数型, , #HKEY_*开头的常量
    .参数 全路径注册项名, 文本型, , 完整的键路径,不包括"HKEY_*" 例如:SOFTWARE\Test
    .局部变量 变量_A2E70225, 文本型

    .如果真 (m_当前键目录 ≠ 键根目录 或 m_当前键 ≠ 全路径注册项名)
        .如果真 (打开键Ex (键根目录, 全路径注册项名) ＝ -1)
            返回 (-1)
        .如果真结束
        
    .如果真结束
    变量_A2E70225 ＝ 取空白文本 (256)
    m_Error ＝ RegEnumKeyA (m_键句柄, 0, 变量_A2E70225, 256)
    .如果真 (m_Error ＝ #ERROR_NO_MORE_ITEMS)
        返回 (0)
    .如果真结束
    .如果真 (m_Error ≠ 0)
        返回 (-1)
    .如果真结束
    返回 (1)

