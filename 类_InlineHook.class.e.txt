.版本 2

.程序集 类_InlineHook, , 公开
.程序集变量 私有_是否被HOOK, 逻辑型
.程序集变量 私有_原字节, 字节集
.程序集变量 私有_新字节, 字节集
.程序集变量 私有_新函数地址, 整数型
.程序集变量 私有_内存地址, 整数型
.程序集变量 私有_内存属性, 精易_内存属性
.程序集变量 私有_目标进程句柄, 整数型
.程序集变量 私有_暂停状态, 逻辑型

.子程序 _初始化
    

.子程序 _销毁
    .如果真 (私有_是否被HOOK)
        卸载HOOK ()
    .如果真结束
    

.子程序 安装HOOK, 整数型, 公开, 安装HOOK，如果已安装HOOK将直接失败。成功返回 #HOOK状态_成功，失败请自行匹配 #HOOK状态_ 系列常量。请在Hook卸载前不要关闭进程句柄！
    .参数 目标进程句柄, 整数型, , -1等于自身进程。如果是其他进程请使用 进程_打开进程() 方法获取句柄。如果是远程进程那么 新函数地址 无论是否为空，都视为拦截HOOK，不会调用到指定函数。
    .参数 欲HOOK的地址, 整数型, , 可通过 地址_取API地址() 方法获取地址。
    .参数 新函数地址, 子程序指针, 可空, 如果为空则设置为拦截HOOK，当被HOOK函数调用时不执行内容，直接返回0。
    .参数 参数数量, 整数型, 可空, 只有新函数地址为空时才有效。这个参数将决定HOOK函数被调用后堆栈平衡问题，请认真填写。
    .局部变量 变量_C2D70225, 字节集

    .如果真 (私有_是否被HOOK)
        返回 (#HOOK状态_已HOOK)
    .如果真结束
    .如果真 (欲HOOK的地址 ＝ 0)
        返回 (#HOOK状态_欲HOOK地址为0)
    .如果真结束
    私有_内存地址 ＝ 欲HOOK的地址
    私有_目标进程句柄 ＝ 目标进程句柄
    修改内存保护属性 (-1, 欲HOOK的地址, 私有_内存属性)
    
    .如果真 (目标进程句柄 ＝ -1)
        
        
        
        
        .如果 (是否为空 (新函数地址))
            
            私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4))
            
        .否则
            
            私有_新字节 ＝ { 233 } ＋ 到字节集 (到整数 (到整数 (新函数地址) － (欲HOOK的地址 ＋ 5)))
        .如果结束
        
        私有_原字节 ＝ 指针到字节集 (欲HOOK的地址, 5)
        
        .如果真 (WriteProcessMemory_字节集 (-1, 欲HOOK的地址, 私有_新字节, 5, 0) ＝ 假)
            返回 (#HOOK状态_写入内存失败)
        .如果真结束
        私有_原字节 ＝ 私有_原字节 ＋ { 233, 0, 0, 0, 0 }
        
        私有_新函数地址 ＝ lstrcpyn_字节集 (私有_原字节, 私有_原字节, 取字节集长度 (私有_原字节))
        
        .如果真 (WriteProcessMemory_字节集 (-1, 私有_新函数地址 ＋ 6, 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10))), 4, 0) ＝ 假)
            返回 (#HOOK状态_写入内存失败)
        .如果真结束
        
        私有_是否被HOOK ＝ 真
        返回 (#HOOK状态_成功)
    .如果真结束
    
    
    
    
    私有_新字节 ＝ { 51, 192, 194 } ＋ 到字节集 (到短整数 (参数数量 × 4))
    
    私有_原字节 ＝ 取空白字节集 (5)
    .如果真 (ReadProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0) ＝ 假)
        
        返回 (#HOOK状态_读取内存失败)
    .如果真结束
    
    私有_新函数地址 ＝ 内存_远程创建内存_字节集 (私有_目标进程句柄, 私有_原字节 ＋ { 233, 0, 0, 0, 0 })
    .如果真 (私有_新函数地址 ＝ 0)
        返回 (#HOOK状态_申请远程内存失败)
    .如果真结束
    变量_C2D70225 ＝ 到字节集 (到整数 (欲HOOK的地址 ＋ 5 － (私有_新函数地址 ＋ 10)))
    .如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_新函数地址 ＋ 6, 变量_C2D70225, 4, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    
    .如果真 (WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0) ＝ 假)
        返回 (#HOOK状态_写入内存失败)
    .如果真结束
    私有_是否被HOOK ＝ 真
    返回 (#HOOK状态_成功)

.子程序 修改内存保护属性, 逻辑型
    .参数 变量_C3D70225, 整数型
    .参数 变量_C4D70225, 整数型
    .参数 变量_C5D70225, 精易_内存属性

    .如果真 (VirtualQueryEx (变量_C3D70225, 变量_C4D70225, 变量_C5D70225, 28) ＝ 0)
        输出调试文本 (“取内存保护属性失败”)
        返回 (假)
    .如果真结束
    .如果真 (VirtualProtectEx (变量_C3D70225, 变量_C5D70225.区域地址, 8, 64, 变量_C5D70225.当前属性) ＝ 0)
        输出调试文本 (“修改内存保护属性失败”)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 还原内存保护属性, 逻辑型
    .参数 变量_C6D70225, 整数型
    .参数 变量_C7D70225, 精易_内存属性

    .如果真 (VirtualProtectEx (变量_C6D70225, 变量_C7D70225.区域地址, 8, 32, 变量_C7D70225.当前属性) ＝ 0)
        返回 (假)
    .如果真结束
    返回 (真)

.子程序 卸载HOOK, 逻辑型, 公开, 卸载HOOK，如果卸载失败可尝试 还原_InlineHook()，传递 取原字节集() 函数即可
    .如果真 (私有_是否被HOOK ＝ 假)
        返回 (假)
    .如果真结束
    
    WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
    
    
    .如果真 (私有_目标进程句柄 ≠ -1)
        内存_释放远程内存 (私有_目标进程句柄, 私有_新函数地址)
    .如果真结束
    还原内存保护属性 (私有_目标进程句柄, 私有_内存属性)
    私有_是否被HOOK ＝ 假
    连续赋值 ({ }, 私有_原字节, 私有_新字节)
    连续赋值 (0, 私有_内存地址, 私有_新函数地址, 私有_目标进程句柄)
    返回 (真)

.子程序 暂停HOOK, 逻辑型, 公开, 暂停(还原)HOOK
    .如果真 (私有_暂停状态 ＝ 假)
        WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_原字节, 5, 0)
        私有_暂停状态 ＝ 真
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 继续HOOK, 逻辑型, 公开, 继续(安装)HOOK
    .如果真 (私有_暂停状态 ＝ 真)
        WriteProcessMemory_字节集 (私有_目标进程句柄, 私有_内存地址, 私有_新字节, 5, 0)
        私有_暂停状态 ＝ 假
        返回 (真)
    .如果真结束
    返回 (假)

.子程序 取地址, 整数型, 公开, 获取一个HOOK地址，这个地址允许被 调用子程序_ 来调用，当调用这个地址时不会触发HOOK函数。请自行区分远程调用和本地调用！
    返回 (私有_新函数地址)

.子程序 取原字节集, 字节集, 公开, 取出备份的原字节集，可用于 还原_InlineHook()函数上
    返回 (私有_原字节)

